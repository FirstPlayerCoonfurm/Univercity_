#include <iostream>
#include <vector>
using namespace std;
// Функция для вывода массива
void print_mass(const vector<int>& mass) {
    // Проходимся по массиву и выводим каждый элемент через пробел
    for (vector<int>::size_type i = 0; i < mass.size(); i++) {
        printf("%d ", mass[i]);
    }
    printf("\n"); // Переход на новую строку после вывода всех элементов
}
// Проверка, является ли число простым
// Передача параметров по значению
int F23_val(int a) {
    int s, n;
    // Пробегаем от 2 до числа 'a' и проверяем, делится ли оно нацело
    for (s = 0, n = 2; n < a; n++) {
        if (a % n == 0) { // Если есть делители кроме самого числа и единицы
            s = 1; // Флаг простого числа устанавливается в 1 (не простое)
            break; // Выходим из цикла, поскольку нашли делитель
        }
    }
    return s; // Возвращаем результат проверки простоты числа
}
// Проверка, является ли число простым
// Передача параметров по ссылке
void F23_ref(const int &a, int &result) {
    int s, n;
    // Аналогично функции F23_val, но результат записывается по ссылке
    for (s = 0, n = 2; n < a; n++) {
        if (a % n == 0) {
            s = 1;
            break;
        }
    }
    result = s; // Запись результата в переменную, переданную по ссылке
}
// Проверка, является ли число простым
// Передача параметров по указателю
void F23_pointer(const int *a, int *result) {
    int s, n;
    // Здесь работаем с числом по указателю '*a'
    for (s = 0, n = 2; n < *a; n++) {
        if (*a % n == 0) {
            s = 1;
            break;
        }
    }
    *result = s; // Результат сохраняется по указателю
}
// Удаление простых чисел из массива
// Передача параметров по значению
void F26_val(vector<int> A, int n) {
    int i, j, s, m;
    // Проходим по каждому элементу массива и проверяем его простоту
    for (i = 0; i < n; i++) {
        for (s = 0, m = 2; m < A[i]; m++) {
            if (A[i] % m == 0) {
                s = 1;
                break;
            }
        }
        if (s == 0) { // Если число простое, удаляем его из массива
            for (j = i; j < n - 1; j++) {
                A[j] = A[j + 1]; // Сдвигаем элементы вправо
            }
            n--; // Уменьшаем размер массива
            i--; // Начинаем проверку заново с предыдущего элемента
        }
    }
}
// Удаление простых чисел из массива
// Передача параметров по ссылке
void F26_ref(vector<int> &A, int &n) {
    int i, j, s, m;
    // Аналогично F26_val, но изменения происходят непосредственно в переданном массиве
    for (i = 0; i < n; i++) {
        for (s = 0, m = 2; m < A[i]; m++) {
            if (A[i] % m == 0) {
                s = 1;
                break;
            }
        }
        if (s == 0) {
            for (j = i; j < n - 1; j++) {
                A[j] = A[j + 1];
            }
            n--;
            i--;
        }
    }
}
// Удаление простых чисел из массива
// Передача параметров по указателю
void F26_pointer(vector<int> *A, int *n) {
    int i, j, s, m;
    // Работаем с массивом через указатель
    for (i = 0; i < *n; i++) {
        for (s = 0, m = 2; m < (*A)[i]; m++) {
            if ((*A)[i] % m == 0) {
                s = 1;
                break;
            }
        }
        if (s == 0) {
            for (j = i; j < *n - 1; j++) {
                (*A)[j] = (*A)[j + 1];
            }
            (*n)--;
            i--;
        }
    }
}
// Нахождение наибольшего общего делителя элементов массива
// Передача параметров по значению
int F28_val(const vector<int> &A, int n) {
    int v, i, s;
    v = A[0] + 1; // Начальное значение НОД больше первого элемента массива
    do {
        v--; // Уменьшаем возможное значение НОД
        for (i = 0, s = 0; i < n; i++) {
            if (A[i] % v != 0) { // Если хотя бы одно число не делится на v
                s = 1; // Обозначаем, что v не подходит
                break; // Прерываем цикл
            }
        }
    } while (s == 1); // Продолжаем искать меньшее значение, пока не найдем подходящий НОД
    return v; // Возвращаем найденный НОД
}
// Нахождение наибольшего общего делителя элементов массива
// Передача параметров по ссылке
void F28_ref(const vector<int> &A, int n, int &result) {
    int v, i, s;
    v = A[0] + 1;
    do {
        v--;
        for (i = 0, s = 0; i < n; i++) {
            if (A[i] % v != 0) {
                s = 1;
                break;
            }
        }
    } while (s == 1);
    result = v; // Сохраняем результат в переменной, переданной по ссылке
}
// Нахождение наибольшего общего делителя элементов массива
// Передача параметров по указателю
void F28_pointer(const vector<int> *A, int n, int *result) {
    int v, i, s;
    v = (*A)[0] + 1;
    do {
        v--;
        for (i = 0, s = 0; i < n; i++) {
            if ((*A)[i] % v != 0) {
                s = 1;
                break;
            }
        }
    } while (s == 1);
    *result = v; // Сохраняем результат по указателю
}
// Нахождение наибольшей степени двойки, меньшей или равной n
// Передача параметров по значению
int F34_val(int n) {
    int k, m;
    // Подсчитываем степень двойки, которая меньше или равна числу 'n'
    for (k = 0, m = 1; m <= n; k++, m = m * 2);
    return k - 1; // Возвращаем степень двойки
}
// Нахождение наибольшей степени двойки, меньшей или равной n
// Передача параметров по ссылке
void F34_ref(const int &n, int &result) {
    int k, m;
    for (k = 0, m = 1; m <= n; k++, m = m * 2);
    result = k - 1; // Сохраняем результат в переменной, переданной по ссылке
}
// Нахождение наибольшей степени двойки, меньшей или равной n
// Передача параметров по указателю
void F34_pointer(const int *n, int *result) {
    int k, m;
    for (k = 0, m = 1; m <= *n; k++, m = m * 2);
    *result = k - 1; // Сохраняем результат по указателю
}
// Переворачивание массива
// Передача параметров по значению
void F35_val(vector<int> c, int n) {
    int i, j, k;
    // Меняем местами первый и последний элементы, второй и предпоследний и т.д.
    for (i = 0, j = n - 1; i < j; i++, j--) {
        k = c[i];
        c[i] = c[j];
        c[j] = k;
    }
}
// Переворачивание массива
// Передача параметров по ссылке
void F35_ref(vector<int> &c, int &n) {
    int i, j, k;
    // То же самое, но изменения производятся непосредственно в переданном массиве
    for (i = 0, j = n - 1; i < j; i++, j--) {
        k = c[i];
        c[i] = c[j];
        c[j] = k;
    }
}
// Переворачивание массива
// Передача параметров по указателю
void F35_pointer(vector<int> *c, int *n) {
    int i, j, k;
    // Работа с массивом через указатели
    for (i = 0, j = *n - 1; i < j; i++, j--) {
        k = (*c)[i];
        (*c)[i] = (*c)[j];
        (*c)[j] = k;
    }
}
int main() {
    vector<int> A1 = {10, 7, 15, 3, 9};           // Первый набор данных
    vector<int> A2 = {20, 13, 25, 5, 17};         // Второй набор данных
    int n1 = 5, n2 = 5;                           // Размеры массивов
    int result2, result3;                          // Переменные для хранения результатов

    // Числа для вызова функций
    int num1 = 7, num2 = 10;

    // ФУНКЦИЯ F23: Проверка на простоту
    printf("---------------------------------------------------------\n");
    printf("F23_val(%d) - %d\n", num1, F23_val(num1));               // Первый вызов
    printf("F23_val(%d) - %d\n", num2, F23_val(num2));               // Второй вызов

    F23_ref(num1, result2);
    printf("F23_ref(%d) - %d\n", num1, result2);                    // Первый вызов
    F23_ref(num2, result2);
    printf("F23_ref(%d) - %d\n", num2, result2);                    // Второй вызов

    F23_pointer(&num1, &result3);
    printf("F23_pointer(%d) - %d\n", num1, result3);                // Первый вызов
    F23_pointer(&num2, &result3);
    printf("F23_pointer(%d) - %d\n", num2, result3);                // Второй вызов

    // ФУНКЦИЯ F26: Удаление простых чисел
    printf("---------------------------------------------------------\n");
    printf("F26_val(A1, %d):\n", n1);
    F26_val(A1, n1);                  // Первый вызов
    print_mass(A1);
    printf("F26_val(A2, %d):\n", n2);
    F26_val(A2, n2);                  // Второй вызов
    print_mass(A2);

    printf("F26_ref(A1, %d):\n", n1);
    F26_ref(A1, n1);                  // Первый вызов
    print_mass(A1);
    printf("F26_ref(A2, %d):\n", n2);
    F26_ref(A2, n2);                  // Второй вызов
    print_mass(A2);

    vector<int> A3 = {10, 7, 15, 3, 9};
    int n3 = 5;
    printf("F26_pointer(A3, %d):\n", n3);
    F26_pointer(&A3, &n3);            // Первый вызов
    print_mass(A3);
    vector<int> A4 = {20, 13, 25, 5, 17};
    int n4 = 5;
    printf("F26_pointer(A4, %d):\n", n4);
    F26_pointer(&A4, &n4);            // Второй вызов
    print_mass(A4);

    // ФУНКЦИЯ F28: Нахождение НОД
    printf("---------------------------------------------------------\n");
    printf("F28_val(A1, %d) - %d\n", n1, F28_val(A1, n1));         // Первый вызов
    printf("F28_val(A2, %d) - %d\n", n2, F28_val(A2, n2));         // Второй вызов

    F28_ref(A1, n1, result2);
    printf("F28_ref(A1, %d) - %d\n", n1, result2);                 // Первый вызов
    F28_ref(A2, n2, result2);
    printf("F28_ref(A2, %d) - %d\n", n2, result2);                 // Второй вызов

    F28_pointer(&A3, n3, &result3);
    printf("F28_pointer(A3, %d) - %d\n", n3, result3);             // Первый вызов
    F28_pointer(&A4, n4, &result3);
    printf("F28_pointer(A4, %d) - %d\n", n4, result3);             // Второй вызов

    // ФУНКЦИЯ F34: Нахождение наибольшей степени двойки
    printf("---------------------------------------------------------\n");
    printf("F34_val(%d) - %d\n", num1, F34_val(num1));              // Первый вызов
    printf("F34_val(%d) - %d\n", num2, F34_val(num2));              // Второй вызов

    F34_ref(num1, result2);
    printf("F34_ref(%d) - %d\n", num1, result2);                   // Первый вызов
    F34_ref(num2, result2);
    printf("F34_ref(%d) - %d\n", num2, result2);                   // Второй вызов

    F34_pointer(&num1, &result3);
    printf("F34_pointer(%d) - %d\n", num1, result3);               // Первый вызов
    F34_pointer(&num2, &result3);
    printf("F34_pointer(%d) - %d\n", num2, result3);               // Второй вызов

    // ФУНКЦИЯ F35: Переворачивание массива
    printf("---------------------------------------------------------\n");
    printf("F35_val(A1, %d):\n", n1);
    F35_val(A1, n1);                        // Первый вызов
    print_mass(A1);
    printf("F35_val(A2, %d):\n", n2);
    F35_val(A2, n2);                        // Второй вызов
    print_mass(A2);

    printf("F35_ref(A1, %d):\n", n1);
    F35_ref(A1, n1);                        // Первый вызов
    print_mass(A1);
    printf("F35_ref(A2, %d):\n", n2);
    F35_ref(A2, n2);                        // Второй вызов
    print_mass(A2);

    vector<int> A5 = {10, 7, 15, 3, 9};
    int n5 = 5;
    printf("F35_pointer(A5, %d):\n", n5);
    F35_pointer(&A5, &n5);                  // Первый вызов
    print_mass(A5);
    vector<int> A6 = {20, 13, 25, 5, 17};
    int n6 = 5;
    printf("F35_pointer(A6, %d):\n", n6);
    F35_pointer(&A6, &n6);                  // Второй вызов
    print_mass(A6);

    return 0;
}
